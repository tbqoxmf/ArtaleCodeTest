"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LinkedList = require("yallist");
const errors_1 = require("../errors");
const decoder_1 = require("./RESP2/decoder");
const encoder_1 = require("./RESP2/encoder");
const pub_sub_1 = require("./pub-sub");
const PONG = Buffer.from('pong');
class RedisCommandsQueue {
    static #flushQueue(queue, err) {
        while (queue.length) {
            queue.shift().reject(err);
        }
    }
    #maxLength;
    #waitingToBeSent = new LinkedList();
    #waitingForReply = new LinkedList();
    #onShardedChannelMoved;
    #pubSub = new pub_sub_1.PubSub();
    get isPubSubActive() {
        return this.#pubSub.isActive;
    }
    #chainInExecution;
    #decoder = new decoder_1.default({
        returnStringsAsBuffers: () => {
            return !!this.#waitingForReply.head?.value.returnBuffers ||
                this.#pubSub.isActive;
        },
        onReply: reply => {
            if (this.#pubSub.isActive && Array.isArray(reply)) {
                if (this.#pubSub.handleMessageReply(reply))
                    return;
                const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(reply);
                if (isShardedUnsubscribe && !this.#waitingForReply.length) {
                    const channel = reply[1].toString();
                    this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
                    return;
                }
                else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(reply)) {
                    const head = this.#waitingForReply.head.value;
                    if ((Number.isNaN(head.channelsCounter) && reply[2] === 0) ||
                        --head.channelsCounter === 0) {
                        this.#waitingForReply.shift().resolve();
                    }
                    return;
                }
                if (PONG.equals(reply[0])) {
                    const { resolve, returnBuffers } = this.#waitingForReply.shift(), buffer = (reply[1].length === 0 ? reply[0] : reply[1]);
                    resolve(returnBuffers ? buffer : buffer.toString());
                    return;
                }
            }
            const { resolve, reject } = this.#waitingForReply.shift();
            if (reply instanceof errors_1.ErrorReply) {
                reject(reply);
            }
            else {
                resolve(reply);
            }
        }
    });
    constructor(maxLength, onShardedChannelMoved) {
        this.#maxLength = maxLength;
        this.#onShardedChannelMoved = onShardedChannelMoved;
    }
    addCommand(args, options) {
        if (this.#maxLength && this.#waitingToBeSent.length + this.#waitingForReply.length >= this.#maxLength) {
            return Promise.reject(new Error('The queue is full'));
        }
        else if (options?.signal?.aborted) {
            return Promise.reject(new errors_1.AbortError());
        }
        return new Promise((resolve, reject) => {
            const node = new LinkedList.Node({
                args,
                chainId: options?.chainId,
                returnBuffers: options?.returnBuffers,
                resolve,
                reject
            });
            if (options?.signal) {
                const listener = () => {
                    this.#waitingToBeSent.removeNode(node);
                    node.value.reject(new errors_1.AbortError());
                };
                node.value.abort = {
                    signal: options.signal,
                    listener
                };
                // AbortSignal type is incorrent
                options.signal.addEventListener('abort', listener, {
                    once: true
                });
            }
            if (options?.asap) {
                this.#waitingToBeSent.unshiftNode(node);
            }
            else {
                this.#waitingToBeSent.pushNode(node);
            }
        });
    }
    subscribe(type, channels, listener, returnBuffers) {
        return this.#pushPubSubCommand(this.#pubSub.subscribe(type, channels, listener, returnBuffers));
    }
    unsubscribe(type, channels, listener, returnBuffers) {
        return this.#pushPubSubCommand(this.#pubSub.unsubscribe(type, channels, listener, returnBuffers));
    }
    resubscribe() {
        const commands = this.#pubSub.resubscribe();
        if (!commands.length)
            return;
        return Promise.all(commands.map(command => this.#pushPubSubCommand(command)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return this.#pushPubSubCommand(this.#pubSub.extendChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return this.#pushPubSubCommand(this.#pubSub.extendTypeListeners(type, listeners));
    }
    getPubSubListeners(type) {
        return this.#pubSub.getTypeListeners(type);
    }
    #pushPubSubCommand(command) {
        if (command === undefined)
            return;
        return new Promise((resolve, reject) => {
            this.#waitingToBeSent.push({
                args: command.args,
                channelsCounter: command.channelsCounter,
                returnBuffers: true,
                resolve: () => {
                    command.resolve();
                    resolve();
                },
                reject: err => {
                    command.reject?.();
                    reject(err);
                }
            });
        });
    }
    getCommandToSend() {
        const toSend = this.#waitingToBeSent.shift();
        if (!toSend)
            return;
        let encoded;
        try {
            encoded = (0, encoder_1.default)(toSend.args);
        }
        catch (err) {
            toSend.reject(err);
            return;
        }
        this.#waitingForReply.push({
            resolve: toSend.resolve,
            reject: toSend.reject,
            channelsCounter: toSend.channelsCounter,
            returnBuffers: toSend.returnBuffers
        });
        this.#chainInExecution = toSend.chainId;
        return encoded;
    }
    onReplyChunk(chunk) {
        this.#decoder.write(chunk);
    }
    flushWaitingForReply(err) {
        this.#decoder.reset();
        this.#pubSub.reset();
        RedisCommandsQueue.#flushQueue(this.#waitingForReply, err);
        if (!this.#chainInExecution)
            return;
        while (this.#waitingToBeSent.head?.value.chainId === this.#chainInExecution) {
            this.#waitingToBeSent.shift();
        }
        this.#chainInExecution = undefined;
    }
    flushAll(err) {
        this.#decoder.reset();
        this.#pubSub.reset();
        RedisCommandsQueue.#flushQueue(this.#waitingForReply, err);
        RedisCommandsQueue.#flushQueue(this.#waitingToBeSent, err);
    }
}
exports.default = RedisCommandsQueue;
