"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("./commands");
const socket_1 = require("./socket");
const commands_queue_1 = require("./commands-queue");
const multi_command_1 = require("./multi-command");
const events_1 = require("events");
const command_options_1 = require("../command-options");
const commander_1 = require("../commander");
const generic_pool_1 = require("generic-pool");
const errors_1 = require("../errors");
const url_1 = require("url");
const pub_sub_1 = require("./pub-sub");
class RedisClient extends events_1.EventEmitter {
    static commandOptions(options) {
        return (0, command_options_1.commandOptions)(options);
    }
    commandOptions = _a.commandOptions;
    static extend(extensions) {
        const Client = (0, commander_1.attachExtensions)({
            BaseClass: _a,
            modulesExecutor: _a.prototype.commandsExecutor,
            modules: extensions?.modules,
            functionsExecutor: _a.prototype.functionsExecuter,
            functions: extensions?.functions,
            scriptsExecutor: _a.prototype.scriptsExecuter,
            scripts: extensions?.scripts
        });
        if (Client !== _a) {
            Client.prototype.Multi = multi_command_1.default.extend(extensions);
        }
        return Client;
    }
    static create(options) {
        return new (_a.extend(options))(options);
    }
    static parseURL(url) {
        // https://www.iana.org/assignments/uri-schemes/prov/redis
        const { hostname, port, protocol, username, password, pathname } = new url_1.URL(url), parsed = {
            socket: {
                host: hostname
            }
        };
        if (protocol === 'rediss:') {
            parsed.socket.tls = true;
        }
        else if (protocol !== 'redis:') {
            throw new TypeError('Invalid protocol');
        }
        if (port) {
            parsed.socket.port = Number(port);
        }
        if (username) {
            parsed.username = decodeURIComponent(username);
        }
        if (password) {
            parsed.password = decodeURIComponent(password);
        }
        if (pathname.length > 1) {
            const database = Number(pathname.substring(1));
            if (isNaN(database)) {
                throw new TypeError('Invalid pathname');
            }
            parsed.database = database;
        }
        return parsed;
    }
    #options;
    #socket;
    #queue;
    #isolationPool;
    #v4 = {};
    #selectedDB = 0;
    get options() {
        return this.#options;
    }
    get isOpen() {
        return this.#socket.isOpen;
    }
    get isReady() {
        return this.#socket.isReady;
    }
    get isPubSubActive() {
        return this.#queue.isPubSubActive;
    }
    get v4() {
        if (!this.#options?.legacyMode) {
            throw new Error('the client is not in "legacy mode"');
        }
        return this.#v4;
    }
    constructor(options) {
        super();
        this.#options = this.#initiateOptions(options);
        this.#queue = this.#initiateQueue();
        this.#socket = this.#initiateSocket();
        // should be initiated in connect, not here
        // TODO: consider breaking in v5
        this.#isolationPool = this.#initiateIsolationPool();
        this.#legacyMode();
    }
    #initiateOptions(options) {
        if (options?.url) {
            const parsed = _a.parseURL(options.url);
            if (options.socket) {
                parsed.socket = Object.assign(options.socket, parsed.socket);
            }
            Object.assign(options, parsed);
        }
        if (options?.database) {
            this.#selectedDB = options.database;
        }
        return options;
    }
    #initiateQueue() {
        return new commands_queue_1.default(this.#options?.commandsQueueMaxLength, (channel, listeners) => this.emit('sharded-channel-moved', channel, listeners));
    }
    #initiateSocket() {
        const socketInitiator = async () => {
            const promises = [];
            if (this.#selectedDB !== 0) {
                promises.push(this.#queue.addCommand(['SELECT', this.#selectedDB.toString()], { asap: true }));
            }
            if (this.#options?.readonly) {
                promises.push(this.#queue.addCommand(commands_1.default.READONLY.transformArguments(), { asap: true }));
            }
            if (this.#options?.name) {
                promises.push(this.#queue.addCommand(commands_1.default.CLIENT_SETNAME.transformArguments(this.#options.name), { asap: true }));
            }
            if (this.#options?.username || this.#options?.password) {
                promises.push(this.#queue.addCommand(commands_1.default.AUTH.transformArguments({
                    username: this.#options.username,
                    password: this.#options.password ?? ''
                }), { asap: true }));
            }
            const resubscribePromise = this.#queue.resubscribe();
            if (resubscribePromise) {
                promises.push(resubscribePromise);
            }
            if (promises.length) {
                this.#tick(true);
                await Promise.all(promises);
            }
        };
        return new socket_1.default(socketInitiator, this.#options?.socket)
            .on('data', chunk => this.#queue.onReplyChunk(chunk))
            .on('error', err => {
            this.emit('error', err);
            if (this.#socket.isOpen && !this.#options?.disableOfflineQueue) {
                this.#queue.flushWaitingForReply(err);
            }
            else {
                this.#queue.flushAll(err);
            }
        })
            .on('connect', () => {
            this.emit('connect');
        })
            .on('ready', () => {
            this.emit('ready');
            this.#setPingTimer();
            this.#tick();
        })
            .on('reconnecting', () => this.emit('reconnecting'))
            .on('drain', () => this.#tick())
            .on('end', () => this.emit('end'));
    }
    #initiateIsolationPool() {
        return (0, generic_pool_1.createPool)({
            create: async () => {
                const duplicate = this.duplicate({
                    isolationPoolOptions: undefined
                }).on('error', err => this.emit('error', err));
                await duplicate.connect();
                return duplicate;
            },
            destroy: client => client.disconnect()
        }, this.#options?.isolationPoolOptions);
    }
    #legacyMode() {
        if (!this.#options?.legacyMode)
            return;
        this.#v4.sendCommand = this.#sendCommand.bind(this);
        this.sendCommand = (...args) => {
            const result = this.#legacySendCommand(...args);
            if (result) {
                result.promise
                    .then(reply => result.callback(null, reply))
                    .catch(err => result.callback(err));
            }
        };
        for (const [name, command] of Object.entries(commands_1.default)) {
            this.#defineLegacyCommand(name, command);
            this[name.toLowerCase()] ??= this[name];
        }
        // hard coded commands
        this.#defineLegacyCommand('SELECT');
        this.#defineLegacyCommand('select');
        this.#defineLegacyCommand('SUBSCRIBE');
        this.#defineLegacyCommand('subscribe');
        this.#defineLegacyCommand('PSUBSCRIBE');
        this.#defineLegacyCommand('pSubscribe');
        this.#defineLegacyCommand('UNSUBSCRIBE');
        this.#defineLegacyCommand('unsubscribe');
        this.#defineLegacyCommand('PUNSUBSCRIBE');
        this.#defineLegacyCommand('pUnsubscribe');
        this.#defineLegacyCommand('QUIT');
        this.#defineLegacyCommand('quit');
    }
    #legacySendCommand(...args) {
        const callback = typeof args[args.length - 1] === 'function' ?
            args.pop() :
            undefined;
        const promise = this.#sendCommand((0, commander_1.transformLegacyCommandArguments)(args));
        if (callback)
            return {
                promise,
                callback
            };
        promise.catch(err => this.emit('error', err));
    }
    #defineLegacyCommand(name, command) {
        this.#v4[name] = this[name].bind(this);
        this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ?
            (...args) => {
                const result = this.#legacySendCommand(name, ...args);
                if (result) {
                    result.promise
                        .then(reply => result.callback(null, command.transformReply(reply)))
                        .catch(err => result.callback(err));
                }
            } :
            (...args) => this.sendCommand(name, ...args);
    }
    #pingTimer;
    #setPingTimer() {
        if (!this.#options?.pingInterval || !this.#socket.isReady)
            return;
        clearTimeout(this.#pingTimer);
        this.#pingTimer = setTimeout(() => {
            if (!this.#socket.isReady)
                return;
            // using #sendCommand to support legacy mode
            this.#sendCommand(['PING'])
                .then(reply => this.emit('ping-interval', reply))
                .catch(err => this.emit('error', err))
                .finally(() => this.#setPingTimer());
        }, this.#options.pingInterval);
    }
    duplicate(overrides) {
        return new (Object.getPrototypeOf(this).constructor)({
            ...this.#options,
            ...overrides
        });
    }
    async connect() {
        // see comment in constructor
        this.#isolationPool ??= this.#initiateIsolationPool();
        await this.#socket.connect();
        return this;
    }
    async commandsExecutor(command, args) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
        return (0, commander_1.transformCommandReply)(command, await this.#sendCommand(redisArgs, options), redisArgs.preserve);
    }
    sendCommand(args, options) {
        return this.#sendCommand(args, options);
    }
    // using `#sendCommand` cause `sendCommand` is overwritten in legacy mode
    #sendCommand(args, options) {
        if (!this.#socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        else if (options?.isolated) {
            return this.executeIsolated(isolatedClient => isolatedClient.sendCommand(args, {
                ...options,
                isolated: false
            }));
        }
        else if (!this.#socket.isReady && this.#options?.disableOfflineQueue) {
            return Promise.reject(new errors_1.ClientOfflineError());
        }
        const promise = this.#queue.addCommand(args, options);
        this.#tick();
        return promise;
    }
    async functionsExecuter(fn, args, name) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
        return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, redisArgs, options), redisArgs.preserve);
    }
    executeFunction(name, fn, args, options) {
        return this.#sendCommand((0, commander_1.fCallArguments)(name, fn, args), options);
    }
    async scriptsExecuter(script, args) {
        const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
        return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, args, options) {
        const redisArgs = ['EVALSHA', script.SHA1];
        if (script.NUMBER_OF_KEYS !== undefined) {
            redisArgs.push(script.NUMBER_OF_KEYS.toString());
        }
        redisArgs.push(...args);
        try {
            return await this.#sendCommand(redisArgs, options);
        }
        catch (err) {
            if (!err?.message?.startsWith?.('NOSCRIPT')) {
                throw err;
            }
            redisArgs[0] = 'EVAL';
            redisArgs[1] = script.SCRIPT;
            return this.#sendCommand(redisArgs, options);
        }
    }
    async SELECT(options, db) {
        if (!(0, command_options_1.isCommandOptions)(options)) {
            db = options;
            options = null;
        }
        await this.#sendCommand(['SELECT', db.toString()], options);
        this.#selectedDB = db;
    }
    select = this.SELECT;
    #pubSubCommand(promise) {
        if (promise === undefined)
            return Promise.resolve();
        this.#tick();
        return promise;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.subscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.unsubscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.subscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.unsubscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.subscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
        return this.#pubSubCommand(this.#queue.unsubscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    getPubSubListeners(type) {
        return this.#queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
        return this.#pubSubCommand(this.#queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
        return this.#pubSubCommand(this.#queue.extendPubSubListeners(type, listeners));
    }
    QUIT() {
        return this.#socket.quit(async () => {
            if (this.#pingTimer)
                clearTimeout(this.#pingTimer);
            const quitPromise = this.#queue.addCommand(['QUIT']);
            this.#tick();
            const [reply] = await Promise.all([
                quitPromise,
                this.#destroyIsolationPool()
            ]);
            return reply;
        });
    }
    quit = this.QUIT;
    #tick(force = false) {
        if (this.#socket.writableNeedDrain || (!force && !this.#socket.isReady)) {
            return;
        }
        this.#socket.cork();
        while (!this.#socket.writableNeedDrain) {
            const args = this.#queue.getCommandToSend();
            if (args === undefined)
                break;
            this.#socket.writeCommand(args);
        }
    }
    executeIsolated(fn) {
        if (!this.#isolationPool)
            return Promise.reject(new errors_1.ClientClosedError());
        return this.#isolationPool.use(fn);
    }
    MULTI() {
        return new this.Multi(this.multiExecutor.bind(this), this.#options?.legacyMode);
    }
    multi = this.MULTI;
    async multiExecutor(commands, selectedDB, chainId) {
        if (!this.#socket.isOpen) {
            return Promise.reject(new errors_1.ClientClosedError());
        }
        const promise = chainId ?
            // if `chainId` has a value, it's a `MULTI` (and not "pipeline") - need to add the `MULTI` and `EXEC` commands
            Promise.all([
                this.#queue.addCommand(['MULTI'], { chainId }),
                this.#addMultiCommands(commands, chainId),
                this.#queue.addCommand(['EXEC'], { chainId })
            ]) :
            this.#addMultiCommands(commands);
        this.#tick();
        const results = await promise;
        if (selectedDB !== undefined) {
            this.#selectedDB = selectedDB;
        }
        return results;
    }
    #addMultiCommands(commands, chainId) {
        return Promise.all(commands.map(({ args }) => this.#queue.addCommand(args, { chainId })));
    }
    async *scanIterator(options) {
        let cursor = 0;
        do {
            const reply = await this.scan(cursor, options);
            cursor = reply.cursor;
            for (const key of reply.keys) {
                yield key;
            }
        } while (cursor !== 0);
    }
    async *hScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.hScan(key, cursor, options);
            cursor = reply.cursor;
            for (const tuple of reply.tuples) {
                yield tuple;
            }
        } while (cursor !== 0);
    }
    async *sScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.sScan(key, cursor, options);
            cursor = reply.cursor;
            for (const member of reply.members) {
                yield member;
            }
        } while (cursor !== 0);
    }
    async *zScanIterator(key, options) {
        let cursor = 0;
        do {
            const reply = await this.zScan(key, cursor, options);
            cursor = reply.cursor;
            for (const member of reply.members) {
                yield member;
            }
        } while (cursor !== 0);
    }
    async disconnect() {
        if (this.#pingTimer)
            clearTimeout(this.#pingTimer);
        this.#queue.flushAll(new errors_1.DisconnectsClientError());
        this.#socket.disconnect();
        await this.#destroyIsolationPool();
    }
    async #destroyIsolationPool() {
        await this.#isolationPool.drain();
        await this.#isolationPool.clear();
        this.#isolationPool = undefined;
    }
    ref() {
        this.#socket.ref();
    }
    unref() {
        this.#socket.unref();
    }
}
_a = RedisClient;
exports.default = RedisClient;
(0, commander_1.attachCommands)({
    BaseClass: RedisClient,
    commands: commands_1.default,
    executor: RedisClient.prototype.commandsExecutor
});
RedisClient.prototype.Multi = multi_command_1.default;
