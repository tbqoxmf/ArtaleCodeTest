"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const net = require("net");
const tls = require("tls");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
class RedisSocket extends events_1.EventEmitter {
    static #initiateOptions(options) {
        options ??= {};
        if (!options.path) {
            options.port ??= 6379;
            options.host ??= 'localhost';
        }
        options.connectTimeout ??= 5000;
        options.keepAlive ??= 5000;
        options.noDelay ??= true;
        return options;
    }
    static #isTlsSocket(options) {
        return options.tls === true;
    }
    #initiator;
    #options;
    #socket;
    #isOpen = false;
    get isOpen() {
        return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
        return this.#isReady;
    }
    // `writable.writableNeedDrain` was added in v15.2.0 and therefore can't be used
    // https://nodejs.org/api/stream.html#stream_writable_writableneeddrain
    #writableNeedDrain = false;
    get writableNeedDrain() {
        return this.#writableNeedDrain;
    }
    #isSocketUnrefed = false;
    constructor(initiator, options) {
        super();
        this.#initiator = initiator;
        this.#options = _a.#initiateOptions(options);
    }
    #reconnectStrategy(retries, cause) {
        if (this.#options.reconnectStrategy === false) {
            return false;
        }
        else if (typeof this.#options.reconnectStrategy === 'number') {
            return this.#options.reconnectStrategy;
        }
        else if (this.#options.reconnectStrategy) {
            try {
                const retryIn = this.#options.reconnectStrategy(retries, cause);
                if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== 'number') {
                    throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
                }
                return retryIn;
            }
            catch (err) {
                this.emit('error', err);
            }
        }
        return Math.min(retries * 50, 500);
    }
    #shouldReconnect(retries, cause) {
        const retryIn = this.#reconnectStrategy(retries, cause);
        if (retryIn === false) {
            this.#isOpen = false;
            this.emit('error', cause);
            return cause;
        }
        else if (retryIn instanceof Error) {
            this.#isOpen = false;
            this.emit('error', cause);
            return new errors_1.ReconnectStrategyError(retryIn, cause);
        }
        return retryIn;
    }
    async connect() {
        if (this.#isOpen) {
            throw new Error('Socket already opened');
        }
        this.#isOpen = true;
        return this.#connect();
    }
    async #connect() {
        let retries = 0;
        do {
            try {
                this.#socket = await this.#createSocket();
                this.#writableNeedDrain = false;
                this.emit('connect');
                try {
                    await this.#initiator();
                }
                catch (err) {
                    this.#socket.destroy();
                    this.#socket = undefined;
                    throw err;
                }
                this.#isReady = true;
                this.emit('ready');
            }
            catch (err) {
                const retryIn = this.#shouldReconnect(retries++, err);
                if (typeof retryIn !== 'number') {
                    throw retryIn;
                }
                this.emit('error', err);
                await (0, utils_1.promiseTimeout)(retryIn);
                this.emit('reconnecting');
            }
        } while (this.#isOpen && !this.#isReady);
    }
    #createSocket() {
        return new Promise((resolve, reject) => {
            const { connectEvent, socket } = _a.#isTlsSocket(this.#options) ?
                this.#createTlsSocket() :
                this.#createNetSocket();
            if (this.#options.connectTimeout) {
                socket.setTimeout(this.#options.connectTimeout, () => socket.destroy(new errors_1.ConnectionTimeoutError()));
            }
            if (this.#isSocketUnrefed) {
                socket.unref();
            }
            socket
                .setNoDelay(this.#options.noDelay)
                .once('error', reject)
                .once(connectEvent, () => {
                socket
                    .setTimeout(0)
                    // https://github.com/nodejs/node/issues/31663
                    .setKeepAlive(this.#options.keepAlive !== false, this.#options.keepAlive || 0)
                    .off('error', reject)
                    .once('error', (err) => this.#onSocketError(err))
                    .once('close', hadError => {
                    if (!hadError && this.#isReady && this.#socket === socket) {
                        this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError());
                    }
                })
                    .on('drain', () => {
                    this.#writableNeedDrain = false;
                    this.emit('drain');
                })
                    .on('data', data => this.emit('data', data));
                resolve(socket);
            });
        });
    }
    #createNetSocket() {
        return {
            connectEvent: 'connect',
            socket: net.connect(this.#options) // TODO
        };
    }
    #createTlsSocket() {
        return {
            connectEvent: 'secureConnect',
            socket: tls.connect(this.#options) // TODO
        };
    }
    #onSocketError(err) {
        this.#isReady = false;
        this.emit('error', err);
        if (!this.#isOpen || typeof this.#shouldReconnect(0, err) !== 'number')
            return;
        this.emit('reconnecting');
        this.#connect().catch(() => {
            // the error was already emitted, silently ignore it
        });
    }
    writeCommand(args) {
        if (!this.#socket) {
            throw new errors_1.ClientClosedError();
        }
        for (const toWrite of args) {
            this.#writableNeedDrain = !this.#socket.write(toWrite);
        }
    }
    disconnect() {
        if (!this.#isOpen) {
            throw new errors_1.ClientClosedError();
        }
        this.#isOpen = false;
        this.#disconnect();
    }
    #disconnect() {
        this.#isReady = false;
        if (this.#socket) {
            this.#socket.destroy();
            this.#socket = undefined;
        }
        this.emit('end');
    }
    async quit(fn) {
        if (!this.#isOpen) {
            throw new errors_1.ClientClosedError();
        }
        this.#isOpen = false;
        const reply = await fn();
        this.#disconnect();
        return reply;
    }
    #isCorked = false;
    cork() {
        if (!this.#socket || this.#isCorked) {
            return;
        }
        this.#socket.cork();
        this.#isCorked = true;
        setImmediate(() => {
            this.#socket?.uncork();
            this.#isCorked = false;
        });
    }
    ref() {
        this.#isSocketUnrefed = false;
        this.#socket?.ref();
    }
    unref() {
        this.#isSocketUnrefed = true;
        this.#socket?.unref();
    }
}
_a = RedisSocket;
exports.default = RedisSocket;
