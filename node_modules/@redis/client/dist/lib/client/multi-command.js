"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("./commands");
const multi_command_1 = require("../multi-command");
const commander_1 = require("../commander");
class RedisClientMultiCommand {
    static extend(extensions) {
        return (0, commander_1.attachExtensions)({
            BaseClass: RedisClientMultiCommand,
            modulesExecutor: RedisClientMultiCommand.prototype.commandsExecutor,
            modules: extensions?.modules,
            functionsExecutor: RedisClientMultiCommand.prototype.functionsExecutor,
            functions: extensions?.functions,
            scriptsExecutor: RedisClientMultiCommand.prototype.scriptsExecutor,
            scripts: extensions?.scripts
        });
    }
    #multi = new multi_command_1.default();
    #executor;
    v4 = {};
    #selectedDB;
    constructor(executor, legacyMode = false) {
        this.#executor = executor;
        if (legacyMode) {
            this.#legacyMode();
        }
    }
    #legacyMode() {
        this.v4.addCommand = this.addCommand.bind(this);
        this.addCommand = (...args) => {
            this.#multi.addCommand((0, commander_1.transformLegacyCommandArguments)(args));
            return this;
        };
        this.v4.exec = this.exec.bind(this);
        this.exec = (callback) => {
            this.v4.exec()
                .then((reply) => {
                if (!callback)
                    return;
                callback(null, reply);
            })
                .catch((err) => {
                if (!callback) {
                    // this.emit('error', err);
                    return;
                }
                callback(err);
            });
        };
        for (const [name, command] of Object.entries(commands_1.default)) {
            this.#defineLegacyCommand(name, command);
            this[name.toLowerCase()] ??= this[name];
        }
    }
    #defineLegacyCommand(name, command) {
        this.v4[name] = this[name].bind(this.v4);
        this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ?
            (...args) => {
                this.#multi.addCommand([name, ...(0, commander_1.transformLegacyCommandArguments)(args)], command.transformReply);
                return this;
            } :
            (...args) => this.addCommand(name, ...args);
    }
    commandsExecutor(command, args) {
        return this.addCommand(command.transformArguments(...args), command.transformReply);
    }
    SELECT(db, transformReply) {
        this.#selectedDB = db;
        return this.addCommand(['SELECT', db.toString()], transformReply);
    }
    select = this.SELECT;
    addCommand(args, transformReply) {
        this.#multi.addCommand(args, transformReply);
        return this;
    }
    functionsExecutor(fn, args, name) {
        this.#multi.addFunction(name, fn, args);
        return this;
    }
    scriptsExecutor(script, args) {
        this.#multi.addScript(script, args);
        return this;
    }
    async exec(execAsPipeline = false) {
        if (execAsPipeline) {
            return this.execAsPipeline();
        }
        return this.#multi.handleExecReplies(await this.#executor(this.#multi.queue, this.#selectedDB, multi_command_1.default.generateChainId()));
    }
    EXEC = this.exec;
    async execAsPipeline() {
        if (this.#multi.queue.length === 0)
            return [];
        return this.#multi.transformReplies(await this.#executor(this.#multi.queue, this.#selectedDB));
    }
}
exports.default = RedisClientMultiCommand;
(0, commander_1.attachCommands)({
    BaseClass: RedisClientMultiCommand,
    commands: commands_1.default,
    executor: RedisClientMultiCommand.prototype.commandsExecutor
});
